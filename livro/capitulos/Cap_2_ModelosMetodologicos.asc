== Modelos Metodológicos

.Objetivos do capítulo
____________________
Ao final deste capítulo você deverá ser capaz de:

* Conhecer os principais modelos de pesquisa.
* Ter uma visão crítica de cada modelo.
* Identificar qual modelo é amplamente usado na Ciência e na Engenharia da computação.
____________________

//Neste lugar você deve apresentar o conteúdo em forma de diálogo.
Neste capítulo se apresenta os principais métodos para fazer pesquisa científica.



=== Introdução

Os modelos são históricos.

=== O modelo empirista

Nesta visão, se estipula que as sensações são as únicas fontes confiáveis para a construção do objeto.
Ou seja, é do comportamento perceptível, superficial e evidente da realidade que devemos construir o objeto.
Esta ideia foi colocada como fundamental na obra "Instauratio Magna" do filósofo inglês Francis Bacon (1561-1626):
Devemos proceder da observação ou da experimentação do real para adquirir um conhecimento da realidade.
O vetor epistemológico preconizado é: realidade=>generalização.
(Porque esta forma? Que acontecia na época?)

Neste modelo, o conhecimento científico é construído pela relação causa-efeito: busca-se encontrar causas possíveis para os fatos (ou efeito) sensíveis (ou superficiais).
Uma pergunta empirista poderia ser:
O que causa a doença de Chagas?

Implicitamente, o modelo empirista não tem como objetivo romper com o senso comum.
Por senso comum trata-se tão-só do sentido que é comum a um conjunto de agentes.

Os empiristas lógicos (Mário Bunge?).
O modelo empirista moderno (denominado por muitos: O Método Científico) é um procedimento que divide o trabalho do cientista nas seguintes etapas:
1) Formulação do problema: Baseado em fatos (comportamento perceptível, superficial), construir perguntas adequadas (O que causa a doença de Chagas?)
2) Construção de Hipótese: Elaborar uma teoria (construção de hipóteses e proposições deduzidas).
3) Experimentação: Construir um experimento que permita verificar a teoria (as hipóteses ou proposições).
4) Se o resultado do experimento é contraditório com a teoria, então voltar ao passo 2).
5) Se o resultado do experimento não é contraditório com a teoria, então a teoria é dita aceitável até o momento.

A teoria é apenas aceitável pois podem existir experimentos que falseiem a teoria, isto é, pode existir um experimento que contradiga a teoria.

Antoine PICON não é empirista, fala sobre os empiristas CONDILLAC.

=== O modelo sistêmico

Neste modelo o objeto de estudo é, por hipótese, um sistema.
Ou seja, assumimos como ponto de partida, que o assunto a ser estudado se comporta como um sistema.

==== A definição de sistema.

Um sistema é um objeto que pode ser subdividido em partes disjuntas e fronteiras definidas.
O sistema possui uma dinâmica definida pela iteração entre as partes que o formam.
As iterações das partes permitem compreender as partes separadamente assim como permitem entender o comportamento do sistema como um todo.
Podemos sintetizar os sistemas como conjuntos de sistemas em iteração.

Exemplo de sistemas em diferentes áreas de conhecimento:

* na biologia: um organismo vivo.
* na matemática: um sistema de equações diferenciais no lineares.
* na psicologia da Gestalt: a existência de sistemas psicológicos.
* nas ciências sociais: o conceito de sociedade.
* na engenharia mecânica: uma ponte, um veiculo.
* na cibernética: um computador.

Todos os sistemas exemplificados acima possuem aspectos em comum:

* podem definir-se partes
* existem iterações entre as partes
* o estudo das partes e do todo deve ser feito observando as iterações entre as partes
* existem abstrações ou modelos conceituais coincidentes em todos os sistemas

Estas ideias são expostas por Bertalanffy na Teoria Geral dos Sistemas.
Esta teoria quer justificar a importância dos princípios gerais aplicáveis aos sistemas.
Bertalanffy sinaliza que a física clássica teve grande sucesso no desenvolvimento da teoria da complexidade não organizada (o comportamento do gás é o resultado do movimento desorganizado de moléculas; em conjunto o comportamento do gás é governado pelas leis da termodinâmica).
Contudo, parece, segundo Bertalanffy, que a física clássica não contribui no estudo dos sistemas complexos e organizados.
A Teoria dos Sistemas quer contribuir na abordagem deste tipo de sistemas.
Mais ainda, a teoria propõe um método científico para abordar o estudo da iteração de um número grande (não infinito) de elementos e processos.

==== Porque surge a teoria dos sistemas?

A existência dos sistemas e sua forma de estudo surge em oposição a percepção mecanicista científica do mundo.
Na visão mecanicista, o todo é divido em partes.
O estudo das partes pode ser feito sem a necessidade vê-lo no lugar onde ele deve estar.
Dito de outra forma, para estudar a parte, isola-se a mesma, desprezando as iterações com as outra partes.
Por fim, o conhecimento do todo se obtêm da soma do funcionamento isolado de cada parte.

Segundo Bertalanffy, os fenômenos biológicos básicos (por exemplo a atividade do sistema nervoso) não podem ser abordados cabalmente com o enfoque mecanicista. Devemos considerar as iterações entre as partes para estudar a parte e o todo.
Assim, o modelo sistêmico surge do conceito de organismo.
O organismo é concebido por partes disjuntas, com fronteiras definidas, porém cada parte interage com as outras.
Para compreender o comportamento das partes, será necessário considerar a parte no lugar onde ela deve estar, dentro do organismo.
Ou seja, para estudar uma parte do organismo, não podemos isolar a parte e assumir que a mesma não interage com outras partes.
Na concepção sistêmica, devemos considerar as interações entre as partes.
Mais ainda, estudar o funcionamento do organismo, como um todo, devemos considerar simultaneamente o funcionamento de todas suas partes, interatuando umas com as outras.

Por outro lado, a teoria geral dos sistemas tenta explicar porque em várias disciplinas da ciência surgem concepções, pontos de vistas e até leis formalmente idênticas (no sentido de que são isomorfas).
(COLOCAR EXEMPLOS PARA FICAR CLARO)
A explicação para esta repetição é atribuída ao fato que estas ciências tem como objeto o estudo de sistemas.

=== O modelo dialético

Nesta seção se apresenta a visão do mundo como matéria em eterna mudança.
A dialética é a expressão no pensar do modo de atuar da matéria.
A matéria é sempre matéria em movimento.
As leis da dialética são as leis da matéria em movimento.
São leis de desenvolvimento na natureza e nas sociedades.
O pensamento dialético reflete a riqueza e a complexidade da realidade cambiante.
Nem nós nem a água são é a mesma quando tomamos banho no mesmo chuveiro duas vezes.

==== Matemática, lógica e dialética.

Esta parte apresenta um exemplo de como se aplica o modelo dialético no enriquecimento da matemática.

===== Qual o objeto da matemática?

aaa

===== Qual o objeto da lógica?

Linguagem da lógica é o Método dedutivo.

===== Onde aparece a dialética na matemática?

Podemos imaginar que o objeto que estamos abordando é governado por diabinhos que estimulam a mudança do objeto.
Como veremos a continuação, no processo de enriquecimento da matemática, precisamos "amarra" os diabinhos para falar na linguagem lógica-matemática, e "soltar" o diabinhos em momentos em que não podemos avançar com o conhecimento do objeto de estudo.
Este "amarrar" e "soltar" é o aspecto marcante no desenvolvimento da matemática.

Quando a lógica entra no campo da matéria em movimento, se torna insuficiente para dar explicações.
Um exemplo disto é o paradoxo clássico de Zeno:
Aquiles e uma tartaruga fazem uma corrida.
Aquiles, sabendo que corre mais rápido, decide dar um vantagem a tartaruga.
A tartaruga partirá de uma posição P_1 a frente de Aquiles P_0.
É dada a largada.
Quando Aquiles chegar na posição P_1 da tartaruga, a tartaruga estará mais a frente na posição P_2.
Quando Aquiles chegar à posição P_2, a tartaruga estará mais a frente na posição P_3.
E assim por diante.
A distância entre a tartaruga e Aquiles d_i é a distância entre os pontos P_i+1 e P_i.
Esta distancia parece que nunca será nula por mais que i seja muito grande.
Como conclusão, Aquiles nunca alcançará a tartaruga.
Mas isto é um contra-senso.

Posicionemo-nos na história.
Como resolver este paradoxo com a lógica da época?
Digamos que até então nossa forma de pensar era algo limitada.
Digamos que não tínhamos como explicar, com a linguagem lógica, porque Aquiles alcançará a tartaruga.
Para resolver o paradoxo precisamos de algo novo, um conceito novo, um objeto que nos permita falar porque Aquiles alcançará a tartaruga.

O conceito novo é a definição de limite da sequencia d_i.
Qualquer que seja a distancia d>0, existirá um i para o qual todos os j maiores que i, a distancia d_j é menor que d.
Isto é verdade pois as distancias d_i entre Aquiles e a tartaruga tornam-se cada vez mais próximas de zero.
Por mais pequeno que seja d>0, sempre encontraremos um i de modo que todos os j>i teremos d_j<d.

O texto do paragrafo anterior é a síntese de um (eventualmente longo) processo dialético.
Tentativas e ensaios, explorações exitosas e fracassadas, intuições o revelações mais ou menos súbitas.
Este processo sempre existem duas caras antagônicas: uma que formaliza (limita o pensamento) dentro da linguagem lógica-matemática e outra que tenta avançar na solução do problema (libera o pensamento).
Digamos que nos momentos de criação, soltamos os diabinhos e ouvimos o que eles tem a nos dizer.
Depois de entender o que eles dizem, tentamos passar este entendimento para a linguagem lógica-matemática, mas esta passagem significa naturalmente o aprisionamento dos mesmos.

No exemplo, o resultado deste processo é a formalização da definição de limite.
Uma vez feita a formalização, a definição de limite, é agora, parte de nossa linguagem lógica-matemática.
Dito de outra forma, depois da formalização, podemos usar a definição para articular melhor a linguagem que usamos.
Mas como o método de trabalho da matemática é o método dedutivo, a formalização é exatamente "amarrar" os diabinhos da dialética.
Neste sentido, o trabalho de formalização do matemático é uma atividade não arbitrária e não livre.
Por outro lado, quando definimos formalmente o limite, estamos aumentando o poder da matemática para resolver problemas (no exemplo, estamos resolvendo o paradoxo de Zeno).
Para deixar claro o aspecto dialético, insisto, a formalização do conceito dentro da linguagem lógica-matemática é simultaneamente "constrangedor" e "libertante".

Os Lógico: A matemática é dedutiva.
JLM: Como deduzir os postulados?

//Conclusão: Dialética parece com o objetivo transformador da ciência.

=== Comentários e exemplos

Texto da sua seção.

==== A engenharia de software e o modelo sistêmico

Nesta seção coloco em evidência elementos da engenharia de software que fazem intersecção com os modelo metodológicos.

A engenharia de software tem como objetivo resolver problemas mediante a construção de um produto, denominado software.
O software é um sistema como definido por Bertalanffy.
Sinteticamente, um software é uma estrutura de partes em interação.

Na linguagem (científica) da engenharia de software quem propõe o problema é denominado de usuário (em inglês: final user, stakeholder).
O usuário também pode ser o comprador do produto ou parte dele.
E quem produz o software é geralmente uma equipe de engenheiros, analistas e programadores de sistemas.
Normalmente o usuário não faz parte da equipe e existe a seguinte relação:
O usuário "pede" e a equipe multidisciplinar "faz" o software, respectivamente.
Esta relação pode existir dentro da equipe de engenheiros, analistas e programadores de sistemas.
Neste caso poderá existir uma divisão do trabalho em sub-equipes.
Cada sub-equipe se ocupa de uma parte do sistema.
Por exemplo: alguns se ocuparão de entender o que o usuário quer, outros se ocupam do projeto, outros se ocupam em programar, etc.

Antes de prosseguir, quero fazer a distinção entre "software" e "programa" (ou programa executável).
Um "programa" é uma das partes comercializáveis e "visíveis" do software que o usuário efetivamente utiliza.
Quando o usuário compra um software, ele geralmente recebe o "programa" (e o manual de uso).
O software contem o "programa" e partes internas que podem ou não são comercializáveis.
Isto é típico com os produtos das engenharias.
Compramos um carro ou partes do carro.
Como usuários finais, não temos acesso ao projeto (design) de engenharia ou partes que dizem como se "faz" o carro.

Existe uma parte do software que esta destinada a chamada *especificação de requisitos*.
Esta especificação nada mais é do que um *postulado* formulado pela equipe ou parte dela.
É neste postulado onde se coloca, "na linguagem (científica) de requisitos", o "que o" o programa deverá resolver.
Esta especificação é como um contrato entre o usuário e a equipe.
Contudo, este contrato pode conter mal-entendidos não detectados inerentes as "linguagens".

Existe outra parte do sistema denominada *projeto*.
A sub-equipe de projetistas recebe como entrada a especificação de requisitos e produz como saída o projeto.
É no projeto onde se coloca a estrutura do sistema e como as partes interagem.
A sub-equipe que faz o projeto terá que formular a especificação de requisitos na "linguagem (cientifica) de projetos", isto é na linguagem de "como" será resolvido o problema.
Certamente, esta estrutura representa um novo postulado que reflete a especificação de requisitos nas mentes dos projetistas.
O projeto é um contrato entre sub-equipes e novamente, este contrato pode conter mal-entendidos intrínsecos por causa das "linguagens".

Existe também a parte que traduz o projeto para uma linguagem de programação que chamamos de *codificação*.
Novamente esta parte tem uma sub-equipe, potencialmente diferente as outras sub-equipes.
O código escrito numa linguagem de programação é mais um postulado, formulação do projeto na "linguagem (cientifica) de programação".

Por último, menciono o modelo classico de organização da produção do software denominado modelo de cascata (waterfall model).
Neste caso realizam-se as seguintes (partes) etapas sequencialmente:
1) "Communication": Nesta etapa se realiza um acordo entre os usuários e uma equipe sobre o problema que se deve resolver. Um dos produtos desta etapa é a especificação de requisitos.
2) "Planning": Nesta atividade fixa-se um plano de trabalho. Se estima os recursos necessários para a produção.
3) "Modelling": Esta é a etapa onde se analisa a realização da especificação de requisitos. Neste momento é onde se diz "como" deve ser feito o software. Um dos produtos desta etapa é o projeto.
4) "Construction": Nesta atividade, se traduz o projeto num programa. O programa é executado e verificado usando os requisitos de software.
5) "Deployment": O software é entregue ao usuário, o mesmo fará a avaliação do produto.


O problema proposto pelo usuário é uma fonte de mal-entendidos para a sub-equipe que desenvolve a especificação de requisitos.
A especificação de requisitos proposto por uma sub-equipe é uma fonte de mal-entendidos para a sub-equipe que desenvolve o projeto.
O projeto proposto por uma sub-equipe é uma fonte de mal-entendidos para a sub-equipe que programa.
, veja algumas possibilidades:
1. A equipe entende errado o problema.
2. O usuário não sabe exatamente o que quer resolver.
3. A equipe tem dificuldades em expressar o problema em sua linguagem.
4. Combinações das anteriores.


//Adicionalmente, um principio importante da engenharia de software é o seguinte:
//Sempre que puder, faça um software modificável.
//Isto quer dizer, o software deve ser um objeto a modificações controláveis pelo engenheiro.
//Existem problemas que não podem ser resolvidos por nenhum programa?
//Quem responde a esta questão é a teoria da computação que se analisa na próxima seção.


==== Como um engenheiro de software pode ser visto como um cientista?

Na engenharia de software, o *engenheiro*, faz o papel de *cientista*.

O *problema* do engenheiro é o *objeto* do cientista.

O engenheiro produz *software*, isto é um *conhecimento novo*.

Os *postulados*, são sub-produtos (científicos do engenheiro) que tentam ajudar na elaboração do programa e assim resolver o problema.
Se os postulados forem falsos (neste caso a equipe que "faz" não entendeu a que "pede"), então a cascata ou parte dela deve ser refeita.
Um dos princípios da engenharia de software é o de "antecipar para a mudança" (Anticipation of Change).
O engenheiro de software pode (e sua formação recomenda) que os postulados sejam fecundos no seguinte sentido:
mudanças nos requisitos de software podem refletir-se em fáceis e rápidas mudanças no projeto.

Por último, realizar *testes* com um software significa fazer *experimentos* cujos resultados devem ser soluções particulares de um problema.
Se existir um experimento em que o problema não é resolvido então devemos revisar os postulados.

==== A teoria da Computação

Texto da subseção.

==== A pesquisa operacional

Texto da subseção.

=== Recapitulando

Revisão do que foi aprendido.

Reserve o último parágrafo para realizar uma *ponte* para o próximo capítulo.

=== Atividades

. Texto da atividade.

. Texto da atividade.

. Texto da atividade.

// Sempre terminar o arquivo com uma nova linha.

